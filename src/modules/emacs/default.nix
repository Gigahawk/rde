{ config, lib, pkgs, inputs, username, ... }:
with lib;
let
  hm = config.home-manager.users.${username};
  emacs-with-pkgs =
    (pkgs.unstable.emacsPackagesGen pkgs.unstable.emacsGit).emacsWithPackages;
  cfg = config.rde.emacs;

  ### Types
  # Source: https://gitlab.com/rycee/nur-expressions/-/blob/master/hm-modules/emacs-init.nix#L9
  packageFunctionType = mkOptionType {
    name = "packageFunction";
    description =
      "Function returning list of packages, like epkgs: [ epkgs.org ]";
    check = isFunction;
    merge = mergeOneOption;
  };

  varType = types.submodule ({ name, config, ... }: {
    options = {
      value = mkOption {
        type = types.either types.str (types.either types.int types.bool);
      };
      docstring = mkOption {
        type = types.str;
        default = "";
      };
    };
  });

  emacsConfigType = types.submodule ({ name, config, ... }: {
    options = {
      enable = mkEnableOption "Enable emacs.configs.${name}.";
      vars = mkOption {
        type = types.attrsOf varType;
        description = "Variable declaration for emacs.configs.${name}.";
      };
      emacsPackages = mkOption {
        type =
          # types.either
          # ((types.listOf types.str) // { description = "List of packages."; })
          packageFunctionType;
        default = epkgs: [ ];
        description = ''
          Emacs package list for this config.
        '';
        example = "epkgs: [ epkgs.org ]";
      };
      config = mkOption {
        type = types.lines;
        description = ''
          Use-package configuration for ${name}.
        '';
      };
      systemPackages = mkOption {
        type = types.listOf types.package;
        description = "System dependencies for ${name}.";
        default = [ ];
      };

    };
    config = mkIf config.enable {
      vars = {
        "rde/config-${name}-enabled".value = true;
        # TODO: add enabled configs variable
      };
    };
  });

  ### Auxiliary functions
  varSetToConfig = v:
    let
      dispatcher = {
        bool = v: if v then "t" else "nil";
        string = v: ''"${v}"'';
      };
      valueToStr = v:
        ((attrByPath [ (builtins.typeOf v) ] toString dispatcher) v);
      ifDocString = v:
        if (stringLength v.docstring > 0) then " \"${v.docstring}\"" else "";
      tmp = mapAttrsToList (name: value: ''
        (defvar ${name} ${valueToStr value.value}${ifDocString value})
      '') v;
    in concatStrings tmp;

  configSetToConfig = v:
    let
      tmp = mapAttrsToList (name: value: ''
        ;;; configs.${name}
        ${value.config}
      '') v;
    in concatStrings tmp;

  enableConfigs = configList:
    foldl (res: name: res // { "${name}".enable = true; }) { } configList;

  mkROFileOption = path:
    (mkOption {
      type = types.path;
      description = "Files autogenerated by rde";
      default = path;
      readOnly = true;
    });

in {

  imports = [ ./configs ];
  options = {
    rde.emacs = {
      enable = mkEnableOption "Enable rde emacs";
      dirs = {
        config = mkOption {
          type = types.path;
          description =
            "Directory, where emacs configuration files will be placed.";
          default = "${hm.xdg.configHome}/emacs";
        };
        data = mkOption {
          type = types.path;
          description =
            "Directory, where emacs configuration files will be placed.";
          default = "${hm.xdg.dataHome}/emacs";
        };
      };
      files = {
        init = mkROFileOption "${cfg.dirs.config}/init.el";
        early-init = mkROFileOption "${cfg.dirs.config}/early-init.el";
        custom = mkOption {
          type = types.path;
          description = "Path to custom.el.";
          default = "${cfg.dirs.data}/custom.el";
        };
      };

      configs = mkOption {
        type = types.attrsOf emacsConfigType;
        description = "Configurations for various packages or package sets";
      };

      vars = mkOption {
        type = types.attrsOf varType;
        description = "Every config adds variable declaration(s) here.";
      };

      font = mkOption {
        type = types.str;
        default = config.rde.font;
      };

      fontSize = mkOption {
        type = types.int;
        default = config.rde.fontSize;
      };

      preset.tropin.enable = mkEnableOption "Enable tropin's configuration.";
      preset.tropin.configList = mkOption {
        type = types.listOf types.str;
        readOnly = true;
        default = [
          "rde-core"
          "rde-defaults"
          "faces"
          "ligatures"
          "icomplete"
          "ibuffer"
          "org-roam"
        ];
      };
    };
  };

  config = mkIf config.rde.emacs.enable {

    rde.emacs.vars = {
      "rde/username" = {
        value = username;
        docstring = "System username provided by rde.";
      };
      "rde/data-dir" = { value = cfg.dirs.data; };
      "rde/custom-file" = {
        value = cfg.files.custom;
        docstring = "Path to custom.el.";
      };
      "rde/font-family".value = cfg.font;
      "rde/font-size".value = cfg.fontSize;
    };

    rde.emacs.configs = mkIf cfg.preset.tropin.enable
      (enableConfigs cfg.preset.tropin.configList);

    home-manager.users."${username}" = {
      home.activation = {
        enusreEmacsDataDir =
          #inputs.home-manager.lib.hm.dag.entryAfter [ "writeBoundary" ]
          ''
            $DRY_RUN_CMD mkdir $VERBOSE_ARG -p ${cfg.dirs.data}
          '';
      };
      home.file."${cfg.files.init}".text = ''
        (require 'rde-variables)
        (require 'rde-configs)
        (provide 'init)
      '';
      home.file."${cfg.files.early-init}".source = ./early-init.el;

      home.packages = with pkgs;
        let
          emacsConfigs = filterAttrs (n: v: v.enable) cfg.configs;
          systemPackageList = concatLists
            (mapAttrsToList (key: value: value.systemPackages) emacsConfigs);
        in systemPackageList ++ [
          emacs-all-the-icons-fonts
          (emacs-with-pkgs (epkgs:
            let
              build-emacs-package = pname: text:
                (epkgs.trivialBuild {
                  pname = pname;
                  version = "1.0";
                  src = pkgs.writeText "${pname}.el" text;
                  packageRequires = [ epkgs.use-package ];
                  preferLocalBuild = true;
                  allowSubstitutes = false;
                });

              concatVarSets = configs:
                let
                  tmp = mapAttrsToList (key: value:
                    ''
                      ;;; Variables by configs.${key}
                    '' + (varSetToConfig value.vars)) configs;
                in concatStrings tmp;
              rde-variables-text = (varSetToConfig cfg.vars)
                + (concatVarSets emacsConfigs) + ''

                  (provide 'rde-variables)
                '';
              rde-variables-package =
                build-emacs-package "rde-variables" rde-variables-text;

              rde-configs-text = (readFile ./rde-configs.el)
                + configSetToConfig emacsConfigs + "(provide 'rde-configs)";
              rde-configs-package =
                build-emacs-package "rde-configs" rde-configs-text;

              packageList = concatLists
                (mapAttrsToList (key: value: (value.emacsPackages epkgs))
                  emacsConfigs);

            in with epkgs;
            packageList ++ [
              rde-variables-package
              rde-configs-package
              nix-mode
              magit
              modus-operandi-theme
              org
              company
              olivetti
              restart-emacs
              keycast
            ]))
        ];
    };
  };
}
